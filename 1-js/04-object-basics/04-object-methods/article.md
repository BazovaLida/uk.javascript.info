# Методи об'єктів, "this"

Об'єкти зазвичай створюються для представлення суб'єктів реального світу, таких як користувачі, замовлення тощо:

```js
let user = {
  name: "John",
  age: 30
};
```

В реальному світі користувач може *діяти*: вибрати щось із кошика для покупок, залогінитись, вийти тощо.

Дії представлені в JavaScript функціями у властивостях.

## Приклади методів

For a start, let's teach the `user` to say hello:
Для початку давайте навчимо `user` (користувача) привітатися:

```js run
let user = {
  name: "John",
  age: 30
};

*!*
user.sayHi = function() {
  alert("Привіт!");
};
*/!*

user.sayHi(); // Привіт!
```

Тут ми використали Вираз Функції для створення функції та призначення їй властивості об'єкта `user.sayHi`.

Тепер ми можемо її викликати. Користувач тепер може говорити!

Функція, яка є властивістю об'єкта, називається *метод*.

Отже, тут у нас є метод `sayHi` об'єкта `user`.

Звичайно, ми могли б використовувати попередньо оголошену функцію як метод:

```js run
let user = {
  // ...
};

*!*
// спочатку, оголосити
function sayHi() {
  alert("Привіт!");
};

// потім додати як метод
user.sayHi = sayHi;
*/!*

user.sayHi(); // Привіт!
```

```smart header="Об'єктно-орієнтоване програмування"
Коли ми пишемо наш код, використовуючи об'єкти для представлення сутностей, це називається [об'єктно-орієнтоване програмування](https://en.wikipedia.org/wiki/Object-oriented_programming), коротше: "ООП".

ООП - це велика річ, своя цікава наука. Як правильно вибрати сутності? Як організувати взаємодію між ними? Це архітектура, і на цю тему є чудові книги, такі як "Design Patterns: Elements of Reusable Object-Oriented Software" E. Gamma, R. Helm, R. Johnson, J. Vissides чи "Object-Oriented Analysis and Design with Applications" G. Booch та ін.
```
### Скорочене оголошення методів

Існує коротший синтаксис для методів:

```js
// ці об’єкти роблять те саме

user = {
  sayHi: function() {
    alert("Hello");
  }
};

// коротший синтаксис виглялає краще, так?
user = {
*!*
  sayHi() { // те само що і "sayHi: function()"
*/!*
    alert("Hello");
  }
};
```

Як показано, ми можемо опустити `"function"` і просто писати `sayHi()`.

По правді кажучи, позначення не є повністю ідентичними. Існують тонкі відмінності, пов’язані з успадкуванням об'єктів (висвітлюються пізніше), але наразі вони не мають значення. Майже у всіх випадках кращим є використання коротшого синтаксис.

## "this" в методах

Загальноприйнято, що для виконання своєї роботи методу потрібно отримати доступ до інформації, що зберігається в об'єкті.

Наприклад, для коду всередині `user.sayHi()` може знадобитися ім'я `user`.

**Для доступу до об’єкта метод може використовувати ключове слово `this`.**

Значенням `this` є об'єкт "before dot", той, який використовується для виклику методу.

Наприклад:

```js run
let user = {
  name: "John",
  age: 30,

  sayHi() {
*!*
    // "this" це "поточний об’єкт"
    alert(this.name);
*/!*
  }

};

user.sayHi(); // John
```

Тут під час виконання `user.sayHi()` значення `this` буде `user`.

Технічно також можна отримати доступ до об'єкта без `this`, посилаючись на нього через зовнішню змінну:

```js
let user = {
  name: "John",
  age: 30,

  sayHi() {
*!*
    alert(user.name); // "user" замість "this"
*/!*
  }

};
```

...Але такий код ненадійний. Якщо ми вирішимо скопіювати `user` в іншу змінну, наприклад `admin = user` і перезаписати `user` на щось інше, тоді він отримає доступ до неправильного об'єкта.

Це продемонстровано нижче:

```js run
let user = {
  name: "John",
  age: 30,

  sayHi() {
*!*
    alert( user.name ); // призводить до помилки
*/!*
  }

};


let admin = user;
user = null; // перешемо, щоб зробити речі очевидними

admin.sayHi(); // Упс! всередині sayHi(), використовується стара назва! помилка! 
```

If we used `this.name` instead of `user.name` inside the `alert`, then the code would work.
Якби ми використовували `this.name` замість `user.name` всередині `alert`, код запрацював би.

## "this" не зв'язане

Поведінка ключового слова `this` у JavaScript відрізняється від більшості інших мов програмування. Його можна використовувати в будь-якій функції.

У наступному прикладі немає синтаксичної помилки:

```js
function sayHi() {
  alert( *!*this*/!*.name );
}
```

Значення `this` оцінюється під час виконання, залежно від контексту.

Наприклад, тут одна і та ж функція відповідає двом різним об'єктам і різним "this" у викликах:

```js run
let user = { name: "John" };
let admin = { name: "Admin" };

function sayHi() {
  alert( this.name );
}

*!*
// використовувати ту саму функцію у двох об’єктах
user.f = sayHi;
admin.f = sayHi;
*/!*

// ці виклики використовують різні this
// "this" всередині функції це об’єкт "before the dot"
user.f(); // John  (this == user)
admin.f(); // Admin  (this == admin)

admin['f'](); // Admin (точки або квадратні дужки отримують доступ до методу - не має значення)
```

Правило просте: якщо викликається `obj.f()`, тоді `this` є `obj` під час виклику `f`. Отже, це або `user`, або `admin` у наведеному вище прикладі.

```smart header="Виклик без об’єкта: `this == undefined`"
Ми навіть можемо взагалі викликати функцію без об'єкта:

```js run
function sayHi() {
  alert(this);
}

sayHi(); // undefined
```

У цьому випадку `this` є `undefined` у суворому режимі. Якщо ми спробуємо отримати доступ до `this.name`, виникне помилка.

У не суворому режимі значенням `this` в такому випадку буде *global object* (`window` (вікно) у браузері, ми дізнаємось про це пізніше в главі [](info:global-object)). Це історична поведінка, яка виправлена `"use strict"`.

Зазвичай такий виклик є помилкою програмування. Якщо всередині функції є `this`, очікується, що воно буде викликане в контексті об'єкта.
````

```smart header="Наслідки незв'язаного `this`"
Якщо ви використовували іншу мову програмування, то, ймовірно, ви звикли до ідеї "зв'язаного `this`", де в методах, визначених в об'єкті, завжди `this` є посиланням на цей об'єкт.

У JavaScript `this` є "вільним", його значення оцінюється під час виклику і не залежить від того, де був оголошений метод, а скоріше від того, який об'єкт знаходиться перед крапкою.

Концепція оцінювання `this` під час виклику має як плюси, так і мінуси. З одного боку, функцію можна повторно використовувати для різних об'єктів. З іншого боку, більша гнучкість створює більше можливостей для помилок.

Тут наша позиція не в тому, щоб судити про те, добре чи погано це рішення дизайну мови. Ми розберемося, як з цим працювати, та як уникнути проблем.
```

## Internals: Тип Посиланнь

```warn header="Поглиблена мовна функція"
Цей розділ охоплює поглиблену тему, щоб краще зрозуміти певні крайні випадки.

Якщо ви хочете продовжувати швидше, це можна пропустити або відкласти.
```

Виклик складного методу може втратити `this`, наприклад:

```js run
let user = {
  name: "John",
  hi() { alert(this.name); },
  bye() { alert("Bye"); }
};

user.hi(); // John (простий виклик працює)

*!*
// тепер давайте викличемо user.hi або user.bye залежно від імені
(user.name == "John" ? user.hi : user.bye)(); // Помилка!
*/!*
```

В останньому рядку є умовний оператор, який вибирає або `user.hi`, або `user.bye`. У цьому випадку результатом є `user.hi`.

Тоді метод негайно викликається в дужках `()`. Але це працює неправильно!

Як бачимо, виклик призводить до помилки, оскільки значення `"this"` всередині виклику стає `undefined`.

Це працює (об'єкт крапка метод):
```js
user.hi();
```

Це не працює (оцінюваний метод):
```js
(user.name == "John" ? user.hi : user.bye)(); // Помилка!
```

Чому? Якщо ми хочемо зрозуміти, чому це відбувається, давайте подивимося, як працює виклик `obj.method()`.

Придивляючись уважно, ми можемо помітити дві операції в операторі `obj.method()`:

1. По-перше, точка `'.'` отримує властивість `obj.method`.
2. Тоді дужки `()` виконують його.

Отже, як інформація про `this` передається з першої частини в другу?

Якщо ми помістимо ці операції в окремі рядки, то `this` буде точно втрачено:

```js run
let user = {
  name: "John",
  hi() { alert(this.name); }
}

*!*
// розділення отримання та виклик методу на два рядки
let hi = user.hi;
hi(); // Помилка, оскільки це не визначено
*/!*
```

Тут `hi = user.hi` присвоює функцію змінній, а потім в останньому рядку вона є повністю автономною, і тому немає `this`.

**Щоб виклики `user.hi()` працювали, JavaScript використовує хитрість -- крапка `'.'` повертає не функцію, а значення спеціального типу посилання [Reference Type](https://tc39.github.io/ecma262/#sec-reference-specification-type).**

Тип Посилання - це "тип специфікації". Ми не можемо прямо використовувати його, але він використовується внутрішньо мовою.

Значення типу посилання - це тризначне поєднання `(base, name, strict)`, де:

- `base` це об'єкт.
- `name` це ім'я властивості.
- `strict` має значення true, якщо `use strict` діє.

Результат доступу до властивості `user.hi` - це не функція, а значення типу посилання. Для `user.hi` в суворому режимі це:

```js
// Значення типу посилання
(user, "hi", true)
```

Коли в посилальному типі викликаються круглі дужки `()`, вони отримують повну інформацію про об'єкт та його метод, і можуть встановити правильний `this` (`=user` в даному випадку).

Тип Посилання - це спеціальний "посередницький" внутрішній тип, мета якого є передача інформації від крапки `.` до виклику в дужках `()`.

Будь-яка інша операція, як присвоєння `hi = user.hi`, відкидає тип посилання в цілому, приймає значення `user.hi` (функція) і передає його далі. Тож будь-яка подальша операція "втрачає" `this`.

Отже, як результат, значення `this` передається правильно, якщо функція викликається безпосередньо за допомогою крапки `obj.method()` або квадратних дужок `obj['method']()`. Пізніше в цьому підручнику ми дізнаємось різні способи вирішення цієї проблеми, такі як [func.bind()](/bind#solution-2-bind).

## Стрілочні функції не мають "this"

Стрілочні функції особливі: вони не мають "свого" `this`. Якщо ми посилаємося на `this` з такої функції, то буде взято взято із зовнішньої «нормальної» функції.

Наприклад, тут `arrow()` використовує `this` від зовнішнього методу `user.sayHi()`:

```js run
let user = {
  firstName: "Ilya",
  sayHi() {
    let arrow = () => alert(this.firstName);
    arrow();
  }
};

user.sayHi(); // Ilya
```

Це особливість стрілочних функцій, це корисно, коли ми насправді не хочемо мати окреме `this`, а скоріше взяти це із зовнішнього контексту. Пізніше у розділі <info:arrow-functions> ми детальніше перейдемо до стрілочних функцій.


## Підсумок

- Функції, які зберігаються у властивостях об'єкта, називаються "методами".
- Методи дозволяють об'єктам "діяти" як `object.doSomething()`.
- Методи можуть посилатись на об'єкт як `this`.

Значення `this` визначається під час виконання.
- Коли функція оголошена, вона може використовувати `this`, але `this` не має значення, поки функція не буде викликана.
- Функція може бути скопійована між об'єктами.
- Коли функція викликається як "метод": `object.method()`, значення `this` під час виклику є `object`.

Зверніть увагу, що стрілочні функції особливі: вони не мають `this`. Коли доступ до `this` відбувається у межах стрілочної функції, значення `this` береться ззовні.
