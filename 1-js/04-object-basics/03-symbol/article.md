
# Символьний тип

За специфікацією, ключі властивостей об'єкту можуть бути або рядкового типу, або символьного типу. Ні в якому разі не цифри чи булев тип, а лише рядки або символи.

До цього часу ми використовували лише рядки. Тепер давайте подивимося на переваги, які можуть нам надати символи.

## Символи

"Символ" являє собою унікальний ідентифікатор.

Значення цього типу можна створити використовуючи `Symbol()`:

```js
// id це новий символ
let id = Symbol();
```

Після створення, ми можемо дати опис символу (його також його називають ім'ям символу), в основному це корисно для налагодження програми:

```js
// id це символ з описом "id"
let id = Symbol("id");
```

Символи гарантовано є унікальними. Навіть якщо ми створимо багато символів з однаковим описом, вони матимуть різні значення. Опис - це лише позначення, яке ні на що не впливає.

Наприклад, ось два символи з однаковим описом -- вони не рівні:

```js run
let id1 = Symbol("id");
let id2 = Symbol("id");

*!*
alert(id1 == id2); // false
*/!*
```

Якщо ви знайомі з Ruby або іншою мовою, яка також має деяке поняття "символи" -- будь ласка, не помиляйтесь. Символи в JavaScript відрізняються.

````warn header="Символи не перетворюються автоматично в рядок"
Більшість значень JavaScript підтримують неявне перетворення в рядок. Наприклад, ми можемо використати "alert" для майже будь-якого значення, і воно буде працювати. Символи особливі. Вони не конвертуються автоматично.

Наприклад, цей `alert` видасть помилку:

```js run
let id = Symbol("id");
*!*
alert(id); // TypeError: Cannot convert a Symbol value to a string
*/!*
```

Це "захист мови" від можливих помилок, тому що рядки та символи принципово різні, і вони не повинні випадково перетворюватися один в інший.

Якщо ми нам дійсно потрібно вивести символ, нам потрібно явно викликати `.toString()`, як тут:
```js run
let id = Symbol("id");
*!*
alert(id.toString()); // Symbol(id), now it works
*/!*
```

Or get `symbol.description` property to show the description only:
Або властивість `symbol.description`, щоб вивести лише опис:
```js run
let id = Symbol("id");
*!*
alert(id.description); // id
*/!*
```

````

## "Приховані" властивості

Символи дозволяють нам створити "приховані" властивості об'єкта, до яких жодна інша частина коду не може випадково отримати доступ або перезаписати.

Наприклад, якщо ми працюємо з `user` об’єктами, які належать до стороннього коду. Ми хотіли б додати до них ідентифікатори.

Давайте використаємо для цього символьний ключ:

```js run
let user = { // належить до іншого коду
  name: "John"
};

let id = Symbol("id");

user[id] = 1;

alert( user[id] ); // ми можемо отримати доступ до даних, використовуючи символ як ключ
```

Яка перевага від використання символу `Symbol("id")` замість рядка `"id"`?

Оскільки `user` об’єкти належать до іншого коду, і цей код також працює з ними, ми не повинні додавати до нього жодні поля. Це небезпечно. Але це неможливо випадково отримати доступ до символу, сторонній код, ймовірно, навіть не побачить його, тому це можна робити.

Крім того, уявіть, що інший скрипт хоче мати власний ідентифікатор всередині `user` для власних цілей. Це може бути ще одна бібліотека JavaScript, так що скрипти абсолютно не знають один про одного.

Тоді цей скрипт може створити власний `Symbol("id")`, таким чином:

```js
// ...
let id = Symbol("id");

user[id] = "Their id value";
```

Між нашими та їхніми ідентифікаторами не буде конфлікту, оскільки символи завжди різні, навіть якщо вони мають однакове ім’я.

...Але якщо ми використали рядок `"id"` замість символу з тією ж метою, то *буде* конфлікт:

```js run
let user = { name: "John" };

// Наш скрипт використовує властивість "id"
user.id = "Our id value";

// ...Інший скрипт також хоче "id" для своїх цілей ...

user.id = "Their id value"
// Бум! переписаний іншим скриптом!
```

### Символи в літералах

Якщо ми хочемо використовувати символ у літералі об'єкту `{...}`, нам потрібні квадратні дужки навколо нього.

Ось так:

```js
let id = Symbol("id");

let user = {
  name: "John",
*!*
  [id]: 123 // не "id: 123"
*/!*
};
```
Це тому, що нам потрібне значення зі змінної `id` як ключ, а не рядок "id".

### Символи опускаються for..in циклом

Символьні властивості не беруть участь у циклі `for..in`.

Наприклад:

```js run
let id = Symbol("id");
let user = {
  name: "John",
  age: 30,
  [id]: 123
};

*!*
for (let key in user) alert(key); // name, age (ніяких символів)
*/!*

// прямий доступ символом працює
alert( "Direct: " + user[id] );
```

`Object.keys(user)` також їх ігнорує. Це частина загального принципу "приховування символьних властивостей". Якщо інший скрипт або бібліотека під час циклу доступаються до об’єкту, вони не отримають доступу до властивості символу.

На відміну від цього, [Object.assign](mdn:js/Object/assign) копіює і властивості рядка, і символу:

```js run
let id = Symbol("id");
let user = {
  [id]: 123
};

let clone = Object.assign({}, user);

alert( clone[id] ); // 123
```

Тут немає парадоксу. Це передбачено дизайном. Ідея полягає в тому, що коли ми клонуємо об’єкт або об'єднуємо об'єкти, то зазвичай хочемо скопіювати *всі* властивості (включаючи такі символи, як `id`).

## Глобальні символи

Як ми бачили, зазвичай всі символи різні, навіть якщо вони мають однакове ім’я. Але іноді ми хочемо, щоб одноіменні символи були однаковими сутностями. Наприклад, різні частини нашої програми хочуть отримати доступ до символу `"id"`, однієї властивості.

Для цього існує *глобальний реєстр символів*. Ми можемо створювати в ньому символи та отримати доступ до них пізніше, і це гарантує, що повторний доступ під одним іменем повертає абсолютно той самий символ.

Для того, щоб прочитати (створити, якщо він відсутній) символ з реєстру, використовуйте `Symbol.for(key)`.

Цей виклик перевіряє глобальний реєстр, і якщо є символ, описаний як `key` (певний ключ), то повертає його, інакше створює новий символ `Symbol(key)` і зберігає його в реєстрі за допомогою заданого `key`.

Наприклад:

```js run
// зчитування з глобального реєстру
let id = Symbol.for("id"); // якщо символ не існував, він створюється

// зчитати його ще раз (можливо, з іншої частини коду)
let idAgain = Symbol.for("id");

// той самий символ
alert( id === idAgain ); // true
```

Символи всередині реєстру називаються *глобальними символами*. Якщо ми хочемо, щоб символ був доступний будь-де у коді у всьому додатку -- ми можемо використовувати глобальні символи.

```smart header="Це звучить як Ruby"
У деяких мовах програмування, як Ruby, є один символ на ім’я.

У JavaScript, як ми бачимо, використовується глобальні символи.
```

### Symbol.keyFor

Для глобальних символів не тільки `Symbol.for(key)` повертає символ через ім'я, але є зворотний виклик: `Symbol.keyFor(sym)`, який робить зворотню дію: повертає ім'я через глобальний символ.

Наприклад:

```js run
// отримати символ за ім'ям
let sym = Symbol.for("name");
let sym2 = Symbol.for("id");

// отримати ім'я за символом
alert( Symbol.keyFor(sym) ); // name
alert( Symbol.keyFor(sym2) ); // id
```

`Symbol.keyFor` внутрішньо використовує глобальний реєстр символів для пошуку ключа для символу. Отже, це не працює для неглобальних символів. Якщо символ не є глобальним, він не зможе його знайти і поверне `undefined`.

Однак це означає, що будь-які символи мають властивість `description`.

Наприклад:

```js run
let globalSymbol = Symbol.for("name");
let localSymbol = Symbol("name");

alert( Symbol.keyFor(globalSymbol) ); // name, глобальний символ
alert( Symbol.keyFor(localSymbol) ); // undefined, не глобальний

alert( localSymbol.description ); // name
```

## Системні символи

Існує багато "системних" символів, які JavaScript використовує внутрішньо, і ми можемо використовувати їх для тонкого налаштування різних аспектів наших об'єктів.

Вони описані в деталях в таблиці [Well-known symbols](https://tc39.github.io/ecma262/#sec-well-known-symbols):

- `Symbol.hasInstance`
- `Symbol.isConcatSpreadable`
- `Symbol.iterator`
- `Symbol.toPrimitive`
- ...і т.д.

Наприклад, `Symbol.toPrimitive` дозволяє нам описати об'єкт до примітивного перетворення. Ми побачимо його використання дуже скоро.

Інші символи також стануть звичними, коли ми вивчимо відповідні особливості мови.

## Підсумок

`Symbol` - примітивний тип унікальних ідентифікаторів.

Символи створюються при виклику `Symbol()` з додатковим описом (ім'ям).

Символи - це завжди різні значення, навіть якщо вони мають однакову назву. Якщо ми хочемо, щоб одноіменні символи були рівними, тоді ми повинні використовувати глобальний реєстр: `Symbol.for(key)` повертає (створює, якщо потрібно) глобальний символ з назвою `key`. Кілька викликів `Symbol.for` з одним і тим же ключем повертають точно той же символ.

Символи мають два основні випадки використання:

1. "Приховані" властивості об'єкта.
    Якщо ми хочемо додати властивість до об'єкта, який "належить" іншому скрипту або бібліотеці, ми можемо створити символ і використовувати його як ключ властивості. Символьна властивість не відображається в циклі `for..in`, тому вона не буде оброблена випадково разом з іншими властивостями. Також до нього не можна буде отримати доступ безпосередньо, оскільки інший скрипт не має нашого символу. Так властивість буде захищено від випадкового використання або перезапису.

    Тож ми можемо "ховати" щось у потрібних нам об'єктах, що інші не повинні бачити, використовуючи символьні властивості.

2. Існує багато системних символів, які використовуються JavaScript, які доступні як `Symbol.*`. Ми можемо використовувати їх для зміни деяких вбудованих способів поведінки. Наприклад, пізніше в підручнику ми будемо використовувати `Symbol.iterator` для [iterables](info:iterable), `Symbol.toPrimitive` для установки [object-to-primitive conversion](info:object-toprimitive) та ін. 

Технічно символи не є на 100% прихованими. Існує вбудований метод [Object.getOwnPropertySymbols(obj)](mdn:js/Object/getOwnPropertySymbols), який дозволяє нам отримувати всі символи. Також існує метод з назвою [Reflect.ownKeys(obj)](mdn:js/Reflect/ownKeys), який повертає *всі* ключі об’єкта, включаючи символічні. Тож вони насправді не приховані. Але більшість бібліотек, вбудованих функцій та синтаксичних конструкцій не використовують ці методи.
