
# Об'єкти

Як ми знаємо з голови <info:types>, в JavaScript існує 8 типів даних. Сім з них називаються "примітивними", так як містять тільки одне значення (будь то рядок, число або щось інше).

Об'єкти ж використовуються для зберігання колекцій різних значень і більш складних сутностей. В JavaScript об'єкти використовуються дуже часто, це одна з основ мови. Тому ми повинні зрозуміти їх, перш ніж заглиблюватися куди-небудь ще.

Об'єкт може бути створений за допомогою фігурних дужок `{...}` з необов'язковим списком *властивостей*. Властивість - це пара "ключ: значення", де `ключ` - це рядок (також званий "ім'ям властивості"), а `значення` може бути чим завгодно.

Ми можемо уявити об'єкт у вигляді ящика з підписаними папками. Кожен елемент даних зберігається у своїй папці, на якій написаний ключ. За ключом папку легко знайти, видалити або додати в неї що-небудь.

![](object.svg)

Порожній об'єкт ("порожній ящик") можна створити, використовуючи один з двох варіантів синтаксису:

```Js
let user = new Object (); // синтаксис "конструктор об'єкта"
let user = {}; // синтаксис "літерал об'єкта"
```

![](object-user-empty.svg)

Зазвичай використовують варіант з фігурними дужками `{...}`. Таке оголошення називають  *літералом об'єкта* або *літеральною нотацією*.

## Літерали і властивості

При використанні літерального синтаксису `{...}` ми відразу можемо помістити в об'єкт кілька властивостей у вигляді пар "ключ: значення":

```Js
let user = { // об'єкт
  name: "John", // під ключом "name" зберігається значення "John"
  age: 30 // під ключом "age" зберігається значення 30
};
```

Властивості об'єкта також іноді називають *полями об'єкта*.

У кожної властивості є ключ (також званий "ім'ям" або "ідентифікатором"). Після імені властивості слідує двокрапка `": "`, і потім вказується значення властивості. Якщо в об'єкті є кілька властивостей, то вони перераховуються через кому.

В об'єкті `user` зараз знаходяться дві властивості:

1. Перша властивість з ім'ям `"name"` і значенням `"John"`.
2. Друга властивість з ім'ям `"age"` і значенням `30`.

Можна сказати, що наш об'єкт `user` - це ящик з двома папками, підписаними "name" та "age".

![user object](object-user.svg)

Ми можемо в будь-який момент додати в нього нові папки, видалити папки або прочитати вміст будь-якої папки.

Для звернення до властивостей використовується запис "через точку":

```Js
// отримуємо властивості об'єкта:
alert (user.name); // John
alert (user.age); // 30
```

Значення може бути будь-якого типу. Давайте додамо властивість з логічним значенням:

```Js
user.isAdmin = true;
```

![user object 2](object-user-isadmin.svg)

Для видалення властивості ми можемо використовувати оператор `delete`:

```Js
delete user.age;
```

![user object 3](object-user-delete.svg)

Ім'я властивості може складатися з декількох слів, але тоді воно має бути укладена в лапки:

```Js
let user = {
  name: "John",
  age: 30,
  "Likes birds": true // ім'я властивості з декількох слів повинно бути в лапках
};
```

![](object-user-props.svg)

Остання властивість об'єкта може закінчуватися комою:

```Js
let user = {
  name: "John",
  age: 30*!*,*/!*
}
```
Це називається "висяча кома". Такий підхід спрощує додавання, видалення і переміщення властивостей, так як всі рядки об'єкта стають однаковими.

## Квадратні дужки

Для властивостей, імена яких складаються з декількох слів, доступ до значення "через точку" не працює:

```Js run
// це викличе синтаксичну помилку
user.likes birds = true
```

JavaScript бачить, що ми звертаємося до властивості `user.likes`, а потім йде незрозуміле слово` birds`. В результаті синтаксична помилка.

Точка вимагає, щоб ключ був іменований за правилами іменування змінних. Тобто не мав прогалин, не розпочинався з цифри і не містив спеціальні символи, крім `$` і `_`.

Для таких випадків існує альтернативний спосіб доступу до властивостей через квадратні дужки. Такий спосіб спрацює з будь-яким ім'ям властивості:

```js run
let user = {};

// присвоювання значення властивості
user["likes birds"] = true;

// отримання значення властивості
alert (user["likes birds"]); // true

// видалення властивості
delete user ["likes birds"];
```

Зараз усе гаразд.

Зверніть увагу, що рядок у квадратних дужках в лапках (підійде будь-який тип лапок).

Квадратні дужки також дозволяють звернутися до властивості, ім'я якої може бути результатом виразу. Наприклад, ім'я властивості може зберігатися в змінної:


```Js
let key = "likes birds";

// те ж саме, що і user ["likes birds"] = true;
user[key] = true;
```

Тут змінна `key` може бути обчислена під час виконання коду або залежати від призначеного для користувача введення. Після цього ми використовуємо її для доступу до властивості. Це дає нам велику гнучкість.

Приклад:

```js run
let user = {
  name: "John",
  age: 30
};

let key = prompt ( "Що ви хочете дізнатися про користувача?", "name");

// доступ до властивості через змінну
alert (user[key]); // John (якщо ввели "name")
```

Запис "через точку" такого не дозволяє:

```Js run
let user = {
  name: "John",
  age: 30
};

let key = "name";
alert (user.key); // undefined
```

### Обчислювані властивості

Ми можемо використовувати квадратні дужки в літеральній нотації для створення *обчислюваної властивості*.

Приклад:

```Js run
let fruit = prompt ( "Який фрукт купити?", "apple");

let bag = {
*!*[Fruit]: 5, // ім'я властивості буде взято зі змінної fruit*/!*
};

alert (bag.apple); // 5, якщо fruit = "apple"
```

Сенс обчислюваної властивості простий: запис `[fruit]` означає, що ім'я властивості необхідно взяти зі змінної `fruit`.

І якщо відвідувач введе слово `"apple"`, то в об'єкті `bag` тепер буде лежати властивість`{apple: 5}`.

По суті, приклад вище працює так само, як і наступний приклад:

```js run
let fruit = prompt ( "Який фрукт купити?", "apple");
let bag = {};

// ім'я властивості буде взято зі змінної fruit
bag[fruit] = 5;
```

... Але перший приклад виглядає лаконічніше.

Ми можемо використовувати і складніші вирази в квадратних дужках:

```Js
let fruit = 'apple';
let bag = {
  [Fruit + 'Computers']: 5 // bag.appleComputers = 5
};
```

Квадратні дужки дають набагато більше можливостей, ніж запис через точку. Вони дозволяють використовувати будь-які імена властивостей і змінні, хоча і вимагають більш громіздких конструкцій коду.

Підіб'ємо підсумок: в більшості випадків, коли імена властивостей відомі і прості, використовується запис через точку. Якщо ж нам потрібно щось більш складне, то ми використовуємо квадратні дужки.

## Властивість зі змінної

У реальному коді нам часто необхідно використовувати існуючі змінні як значення для властивостей з тим же ім'ям.

Наприклад:

```Js run
function makeUser (name, age) {
  return {
    name: name,
    age: age
    // ... інші властивості
  };
}

let user = makeUser ( "John", 30);
alert (user.name); // John
```

В наведеному вище прикладі назва властивостей `name` і` age` збігаються з назвами змінних, які ми підставляємо в якості значень цих властивостей. Такий підхід настільки поширений, що існують спеціальні *короткі властивості* для спрощення цього запису.

Замість `name: name` ми можемо написати просто `name`:

```Js
function makeUser (name, age) {
*!*
  return {
    name, // те ж саме, що і name: name
    age // те ж саме, що і age: age
    // ...
  };
*/!*
}
```

Ми можемо використовувати як звичайні властивості, так і короткі в одному і тому ж об'єкті:

```Js
let user = {
  name, // те ж саме, що і name: name
  age: 30
};
```

## Обмеження на імена властивостей

Ми можемо використовувати тільки рядки і символи в якості ключів властивостей. Всі інші типи даних будуть автоматично перетворені до рядка.

Наприклад, якщо використовувати як ключ число `0`, то воно перетвориться в рядок` "0" `:

```Js run
let obj = {
  0: "Тест" // те ж саме що і "0": "Тест"
};

// обидві функції alert виведуть одну і ту ж властивість (число 0 перетворюється в рядок "0")
alert (obj["0"]); // Тест
alert (obj[0]); // Тест (та ж властивість)
```

**Зарезервовані слова дозволено використовувати як імена властивостей.**

Як ми вже знаємо, ім'я змінної не може збігатися з зарезервованими словами, такими як "for", "let", "return" і т.д.

Але для властивостей об'єкта такого обмеження немає:

```js run
let obj = {
  for: 1,
  let: 2,
  return: 3
};

alert (obj.for + obj.let + obj.return); // 6
```

**У принципі, дозволені будь-які імена властивостей, але є спеціальна властивість `__proto__`, яка з історичних причин має особливу поведінку.**

Наприклад, його значення завжди повинно бути об'єктом:

```Js run
let obj = {};
obj.__ proto__ = 5;
alert (obj .__ proto__); // [object Object], працює не так, як ми очікували
```

Як ми бачимо, присвоювання примітивного значення `5` ігнорується.

Ми більш детально досліджуємо властивість `__proto__` пізніше, в розділі [](info:prototype-inheritance).

Зараз важливо знати, що така поведінка `__proto__` може стати джерелом помилок і навіть вразливостей, якщо ми маємо намір зберігати в об'єкті довільні дані і дозволяємо відвідувачам вказувати ключі.

Відвідувач може вказати `" __proto __ "` як ключ, і логіка присвоювання буде порушена (як показано вище).

Пізніше ми вивчимо, як обійти цю проблему:
1. Можна змусити об'єкт обробляти `__proto__` як звичайне властивість, ми це побачимо в главі [](info:prototype-methods).
2. Є інша структура даних [Map](info:map-set), яку ми вивчимо в розділі <info:map-set>, вона підтримує довільні ключі.

## Перевірка на існування властивості, оператор "in"

Особливість об'єктів в тому, що можна отримати доступ до будь-якої властивості. Навіть якщо властивості не існує - помилки не буде! При зверненні до властивості, якої немає, повертається `undefined`. Це дозволяє просто перевірити існування властивості - порівнянням її з `undefined`:

```js run
let user = {};

alert (user.noSuchProperty === undefined); // true означає, що "властивості немає"
```

Також існує спеціальний оператор `"in"` для перевірки на існування властивості в об'єкті.

Синтаксис оператора:
```Js
"Key" in object
```

Приклад:

```Js run
let user = {name: "John", age: 30};

alert ("age" in user); // true, user.age існує
alert ("blabla" in user); // false, user.blabla не існує
```

Зверніть увагу, що зліва від оператора `in` має бути *ім'я властивості*. Зазвичай це рядок в лапках.

Якщо ми опускаємо лапки, це означає, що ми вказуємо змінну, в якій знаходиться ім'я властивості. Наприклад:

```js run
let user = {age: 30};

let key = "age";
alert (*!*key*/!* in user); // true, ім'я властивості було взято зі змінної key
```

````smart header="Оператор \"in\" для властивостей зі значенням *'undefined'*"
Зазвичай суворого порівняння `"=== undefined"` досить для перевірки наявності властивості. Але є особливий випадок, коли воно не підходить, і потрібно використовувати `"in"`.

Це коли властивість існує, але містить значення `undefined`:

```js run
let obj = {
  test: undefined
};

alert (obj.test); // виведе undefined, значить властивість не існує ?

alert ( "test" in obj); // true, властивість існує!
```

В наведеному вище прикладі властивість `obj.test` технічно існує в об'єкті. Оператор `in` спрацював правильно.

Подібні ситуації трапляються дуже рідко, так як `undefined` зазвичай явно не присвоюється. Для "невідомих" або "порожніх" властивостей ми використовуємо значення `null`. Таким чином, оператор `in` є екзотичним гостем у коді.

````

## Цикл "for..in"

Для перебору всіх властивостей об'єкта використовується цикл `for..in`. Цей цикл відрізняється від вивченого раніше циклу `for (;;)`.

Синтаксис:

```Js
for (key in object) {
  // тіло циклу виконується для кожної властивості об'єкта
}
```

Наприклад, давайте виведемо всі властивості об'єкта `user`:

```js run
let user = {
  name: "John",
  age: 30,
  isAdmin: true
};

for (let key in user) {
  // ключі
  alert (key); // name, age, isAdmin
  // значення ключів
  alert (user [key]); // John, 30, true
}
```


Зверніть увагу, що всі конструкції "for" дозволяють нам оголошувати змінну всередині циклу, як, наприклад, `let key` тут.

Крім того, ми могли б використовувати інше ім'я змінної. Наприклад, часто використовується варіант `"for (let prop in obj)"`.


### Впорядкування властивостей об'єкта

Чи впорядковані властивості об'єкта? Іншими словами, якщо ми будемо в циклі перебирати всі властивості об'єкта, чи отримаємо ми їх в тому ж порядку, в якому ми їх додавали? Чи можемо ми на це розраховувати?

Коротка відповідь: властивості впорядковані особливим чином: властивості з цілочисельними ключами сортуються за зростанням, інші розташовуються в порядку створення. Розберемося докладніше.

Як приклад розглянемо об'єкт з телефонними кодами:

```Js run
let codes = {
  "49": "Німеччина",
  "41": "Швейцарія",
  "44": "Великобританія",
  // ..,
  "1": "США"
};

*!*
for (let code in codes) {
  alert (code); // 1, 41, 44, 49
}
*/!*
```

Якщо ми робимо сайт для німецької аудиторії, то, ймовірно, ми хочемо, щоб код `49` був першим.

Але якщо ми запустимо код, ми побачимо зовсім іншу картину:

- США (1) йде першим
- потім Швейцарія (41) і так далі.

Телефонні коди йдуть в порядку зростання, тому що вони є цілими числами: `1, 41, 44, 49`.

```smart header="Цілочисельні властивості? Це що?"
Термін "цілочисельна властивість" означає рядок, який може бути перетворений в ціле число і назад без змін.

Тобто, `"49"` - це цілочисельне ім'я властивості, тому що якщо його перетворити в ціле число, а потім назад в рядок, то воно не зміниться. А ось властивості `"+49 "` або `"1.2"` такими не є:

```js run
// Math.trunc - вбудована функція, яка видаляє десяткову частину
alert (String (Math.trunc (Number ( "49")))); // "49", те ж саме ⇒ властивість цілочисельна
alert (String (Math.trunc (Number ( "+ 49")))); // "49", не те ж саме, що "+49" ⇒ властивість не цілочисельна
alert (String (Math.trunc (Number ( "1.2")))); // "1", не те ж саме, що "1.2" ⇒ властивість не цілочисельна
```


... З іншого боку, якщо ключі не цілочисельні, то вони перебираються в порядку створення, наприклад:

```js run
let user = {
  name: "John",
  surname: "Smith"
};
user.age = 25; // додамо ще одну властивість

*!*
// НЕ цілочисельні властивості перераховані в порядку створення
*/!*
for (let prop in user) {
  alert (prop); // name, surname, age
}
```

Таким чином, щоб вирішити нашу проблему з телефонними кодами, ми можемо схитрувати, зробивши ці коди не цілочисельними властивостями. Додавання знака `"+"` перед кожним кодом буде достатньо.

Приклад:

```Js run
let codes = {
  "+49": "Німеччина",
  "+41": "Швейцарія",
  "+44": "Великобританія",
  // ..,
  "+1": "США"
};

for (let code in codes) {
  alert (+ code); // 49, 41, 44, 1
}
```

Тепер код працює так, як ми задумували.

## Копіювання за посиланням

Одною з фундаментальних відмінностей об'єктів від примітивних типів даних є те, що вони зберігаються і копіюються "за посиланням".

Примітивні типи: рядки, числа, логічні значення - присвоюються і копіюються "за значенням".

Наприклад:
```js
let message = "Hello!";
let phrase = message;
```

В результаті ми маємо дві незалежні змінні, кожна з яких зберігає рядок `"Hello!"`.

![](variable-copy-value.svg)


Об'єкти поводяться інакше.

**Мінлива зберігає не сам об'єкт, а його "адреса в пам'яті", іншими словами "посилання" на нього.**

Проілюструємо це:

```js
let user = {
  name: "John"
};
```

![](variable-contains-reference.svg)

Сам об'єкт зберігається десь в пам'яті. А в змінній `user` лежить "посилання" на цю область пам'яті.

**Коли змінна об'єкта копіюється - копіюється посилання, сам же об'єкт не дублюється.**

Якщо ми представляємо об'єкт як ящик, то змінна - це ключ до нього. Копіювання змінної дублює ключ, але не сам ящик.

Наприклад:

```js no-beautify
let user = {name: "John"};

let admin = user; // копіюється посилання
```

Тепер у нас є дві змінні, кожна з яких містить посилання на один і той же об'єкт:

![](variable-copy-reference.svg)

Ми можемо використовувати будь-яку зі змінних для доступу до ящика і зміни його вмісту:

```js run
let user = {name: 'John'};

let admin = user;

admin.name = 'Pete'; // змінено за посиланням зі змінної "admin"


alert (*!*user.name*/!*); // 'Pete', зміни видно по посиланню зі змінної "user"
```

Наведений вище приклад демонструє, що об'єкт тільки один. Якби то у нас один ящик з двома ключами і ми використовуємо один з них (`admin`), щоб увійти в нього і щось змінити, а потім, відкривши ящик іншим ключем (`user`), ми б побачили ці зміни.

### Порівняння об'єктів

Оператори рівності `==` і суворої рівності `===` для об'єктів працюють однаково.

**Два об'єкти рівні тільки в тому випадку, якщо це один і той же об'єкт.**

Наприклад, дві змінні посилаються на один і той же об'єкт, вони рівні:

```js run
let a = {};
let b = a; // копіювання за посиланням

alert (a == b); // true, обидві змінні посилаються на один і той же об'єкт
alert (a === b); // true
```

У прикладі нижче два різних об'єкта не рівні, хоча і обидва порожні:

```js run
let a = {};
let b = {}; // два незалежних об'єкта

alert (a == b); // false
```

Для порівнянь типу `obj1 > obj2` або для порівняння з примітивом` obj == 5` об'єкти перетворюються в примітиви.

Незабаром ми вивчимо, як працюють такі перетворення об'єктів, але, по правді кажучи, порівняння такого роду необхідні дуже рідко і зазвичай є результатом помилки програміста.

### Об'єкти-константи

Об'єкт, оголошений через `const`, * може * бути змінений.

приклад:

```js run
const user = {
  name: "John"
};

*!*
user.age = 25; // (*)
*/!*

alert (user.age); // 25
```

Може здатися, що рядок `(*)` повинен викликати помилку, але немає, тут все в порядку. Справа в тому, що оголошення `const` захищає від змін тільки саме значення `user`. А в нашому випадку значення `user` - це посилання на об'єкт, і це значення ми не змінюємо. У рядку `(*)` ми діємо *всередині* об'єкта, ми не перепризначуваємо `user`.

Якщо ж ми спробуємо присвоїти `user` інше значення, то `const` видасть помилку:

```js run
const user = {
  name: "John"
};

*!*
// Помилка (не можна перевизначати константу user)
*/!*
user = {
  name: "Pete"
};
```

... Але що робити, якщо ми хочемо зробити константами властивості об'єкта? Як зробити так, щоб спроба змінити `user.age = 25` видавала помилку? Це теж можливо. Ми розглянемо цю тему в розділі <info:property-descriptors>.

## Клонування і об'єднання об'єктів, Object.assign

Як ми дізналися раніше, при копіюванні змінної об'єкта створюється ще одне посилання на той же самий об'єкт.

Але що, якщо нам все ж потрібно дублювати об'єкт? Створити незалежну копію, клон?

Це здійснимо, але трохи складно, так як в JavaScript немає вбудованого методу для цього. Насправді, така потреба виникає рідко. У більшості випадків нам досить копіювання за посиланням.

Але якщо ми дійсно цього хочемо, то нам потрібно створювати новий об'єкт і повторювати структуру дубльованого об'єкта, перебираючи його властивості і копіюючи їх.

Наприклад так:

```js run
let user = {
  name: "John",
  age: 30
};

*!*
let clone = {}; // новий порожній об'єкт

// скопіюємо все властивості user в нього
for (let key in user) {
  clone [key] = user [key];
}
*/!*

// тепер в змінній clone знаходиться абсолютно незалежний клон об'єкта.
clone.name = "Pete"; // змінимо в ньому дані

alert (user.name); // в оригінальному об'єкті значення властивості `name` залишилося колишнім - John.
```

Крім того, для цих цілей ми можемо використовувати метод  [Object.assign](mdn:js/Object/assign).

Синтаксис:

```js
Object.assign (dest, [src1, src2, src3 ...])
```

- Аргументи `dest`, і `src1, ..., srcN` (може бути стільки, скільки потрібно) є об'єктами.
- Метод копіює властивості всіх об'єктів `src1, ..., srcN` в об'єкт` dest`. Тобто, властивості всіх перерахованих об'єктів, починаючи з другого, копіюються в перший об'єкт. Після копіювання метод повертає об'єкт `dest`.

Наприклад, об'єднаємо декілька об'єктів в один:

```js
let user = {name: "John"};

let permissions1 = {canView: true};
let permissions2 = {canEdit: true};

*! *
// копіюємо всі властивості з permissions1 і permissions2 в user
Object.assign (user, permissions1, permissions2);
*/!*

// наразі user = {name: "John", canView: true, canEdit: true}
```

Якщо приймаючий об'єкт (`user`) вже має властивість з таким ім'ям, воно буде перезаписано:

```js
let user = {name: "John"};

// властивість name перезапишеться, властивість isAdmin додасться
Object.assign (user, {name: "Pete", isAdmin: true});

// наразі user = {name: "Pete", isAdmin: true}
```

Ми також можемо використовувати `Object.assign` для простого клонування:

```Js
let user = {
  name: "John",
  age: 30
};

*!*
let clone = Object.assign ({}, user);
*/!*
```

Всі властивості об'єкта `user` будуть скопійовані в порожній об'єкт, і посилання на цей об'єкт буде в змінній `clone`. Насправді, таке клонування працює так само, як і через цикл, але коротше.

До цього часу ми припускали, що всі властивості користувача примітивні. Але властивості можуть бути посиланнями на інші об'єкти. Що з ними робити?

Наприклад, є об'єкт:

```Js run
let user = {
  name: "John",
  sizes: {
    height: 182,
    width: 50
  }
};

alert (user.sizes.height); // 182
```

Тепер при клонуванні недостатньо просто скопіювати `clone.sizes = user.sizes`, оскільки ` user.sizes` - це об'єкт, він буде скопійований за посиланням. А значить об'єкти `clone` і ` user` у своїх властивостях `sizes` будуть посилатися на один і той же об'єкт:

```js run
let user = {
  name: "John",
  sizes: {
    height: 182,
    width: 50
  }
};

let clone = Object.assign ({}, user);

alert (user.sizes === clone.sizes); // true, один і той же об'єкт

// user і clone звертаються до одного sizes
user.sizes.width ++; // змінюємо властивість в одному об'єкті
alert (clone.sizes.width); // 51, бачимо результат в іншому об'єкті
```

Щоб виправити це, ми повинні в циклі клонування робити перевірку, чи не є значення `user[key]` об'єктом, і якщо це так - копіюємо і його структуру теж. Це називається "глибоке клонування".

Існує стандартний алгоритм глибокого клонування, [Structured cloning algorithm](http://w3c.github.io/html/infrastructure.html#safe-passing-of-structured-data). Він вирішує описану вище задачу, а також більш складні завдання.
Щоб не винаходити велосипед, ми можемо використовувати реалізацію цього алгоритму з JavaScript-бібліотеки [lodash](https://lodash.com), метод [_.cloneDeep (obj)](https://lodash.com/docs#cloneDeep).

## Підсумок

Об'єкти - це асоціативні масиви з рядом додаткових можливостей.

Вони зберігають властивості (пари ключ-значення), де:
- Ключі властивостей повинні бути рядками або символами (зазвичай рядками).
- Значення можуть бути будь-якого типу.

Щоб отримати доступ до властивості, ми можемо використовувати:
- Запис через точку: `obj.property`.
- Квадратні дужки `obj["property"]`. Квадратні дужки дозволяють взяти ключ зі змінної, наприклад, `obj[varWithKey]`.

Додаткові оператори:

- Видалення властивості: `delete obj.prop`.
- Перевірка існування властивості: `" key "in obj`.
- Перебір властивостей об'єкта: цикл for `for (let key in obj)`.

Об'єкти присвоюються і копіюються за посиланням. Іншими словами, змінна зберігає не "значення об'єкта", а "посилання" (адресу в пам'яті) на це значення. Тому копіювання такої змінної або передача її в якості аргументу функції призводить до копіювання цього посилання, а не самого об'єкта. Всі операції з використанням скопійованих посилань (наприклад, додавання або видалення властивостей) виконуються з одним і тим же об'єктом.

Щоб зробити "справжню копію" (клон), ми можемо використовувати `Object.assign` або [_.cloneDeep (obj)](https://lodash.com/docs#cloneDeep).

Те, що ми вивчали в цьому розділі, називається "простим об'єктом" ("plain object") або просто `Object`.

В JavaScript є багато інших типів об'єктів:

- `Array` для зберігання впорядкованих колекцій даних,
- `Date` для зберігання інформації про дату і час,
- `Error` для зберігання інформації про помилку.
- ...і так далі.

У них є свої особливості, які ми вивчимо пізніше. Іноді люди говорять щось на кшталт "тип даних Array" або "тип даних Date", але формально вони не є окремими типами, а відносяться до типу даних `Object`. Вони лише розширюють його різними способами.

Об'єкти в JavaScript дуже потужні. Тут ми тільки трохи заглибилися в дійсно величезну тему. Ми будемо щільно працювати з об'єктами і дізнаємося про них більше в наступних частинах підручника.
