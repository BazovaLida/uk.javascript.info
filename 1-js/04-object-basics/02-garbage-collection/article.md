# Прибирання сміття

Управління пам'яттю в JavaScript виконується автоматично і непомітно. Ми створюємо примітиви, об'єкти, функції... Все це займає пам'ять.

Але що відбувається, коли щось більше не потрібно? Як JavaScript розуміє, що пора очищати пам'ять?

## Досяжність

Основною концепцією управління пам'яттю в JavaScript є принцип *досяжності*.

Якщо спростити, то "досяжні" значення - це ті, які доступні або використовуються. Вони гарантовано знаходяться в пам'яті.

1. Існує безліч досяжних значень, які не можуть бути видалені.

    Наприклад:
    - Локальні змінні і параметри поточної функції
    - Змінні і параметри інших функцій в поточному ланцюжку вкладених викликів
    - Глобальні змінні
    - (деякі інші внутрішні значення)
    Ці значення ми будемо називати *коренями*.

2. Будь-яке інше значення вважається досяжним, якщо воно встановлено із кореня за посиланням або по ланцюжку посилань.

    Наприклад, якщо в локальній змінній є об'єкт, і він має властивість, в якій зберігається посилання на інший об'єкт, то цей об'єкт вважається досяжним. І ті, на які він посилається, теж досяжні. Далі ви познайомитеся з докладними прикладами на цю тему.

У інтерпретаторі JavaScript є фоновий процес, який називається [збирач сміття](https://uk.wikipedia.org/wiki/Збирання_сміття). Він стежить за всіма об'єктами і видаляє ті, які стали недосяжними.

## Простий приклад

Ось найпростіший приклад:

```js
// в user знаходиться посилання на об'єкт
let user = {
  name: "John"
};
```

![](memory-user-john.svg)

Тут стрілка позначає посилання на об'єкт. Глобальна змінна `user` посилається на об'єкт `{name: "John"}`(ми будемо називати його просто" John "). У властивості `"name"` об'єкта John зберігається примітив, тому воно намальовано всередині об'єкта.

Якщо перезаписати значення `user`, то посилання загубиться:

```js
user = null;
```

![](memory-user-john-lost.svg)

Тепер об'єкт John стає недосяжним. До нього немає доступу, на нього немає посилань. Збирач сміття видалить ці дані і звільнить пам'ять.

## Два посилання

Уявімо, що ми скопіювали посилання з `user` в `admin`:

```js
// в user знаходиться посилання на об'єкт
let user = {
  name: "John"
};

*!*
let admin = user;
*/!*
```

![](memory-user-john-admin.svg)

Тепер, якщо ми зробимо те ж саме:
```js
user = null;
```

... то об'єкт John все ще досяжний через глобальну змінну `admin`, тому він знаходиться в пам'яті. Якби ми також перезаписали `admin`, то John був би видалений.

## Взаємозв'язані об'єкти

Тепер складніший приклад. Сім'я:

```js
function marry (man, woman) {
  woman.husband = man;
  man.wife = woman;

  return {
    father: man,
    mother: woman
  }
}

let family = marry ({
  name: "John"
}, {
  name: "Ann"
});
```

Функція `marry`" одружує "два об'єкти, даючи їм посилання один на одного, і повертає новий об'єкт, що містить посилання на два попередніх.

В результаті отримуємо таку структуру пам'яті:

![](family.svg)

На даний момент всі об'єкти досяжні.

Тепер видалимо два посилання:

```js
delete family.father;
delete family.mother.husband;
```

![](family-delete-refs.svg)

Недостатньо видалити тільки одну з цих посилань, тому що всі об'єкти залишаться досяжними.

Але якщо ми видалимо обидві, то побачимо, що в об'єкта John більше немає вхідних посилань:

![](family-no-father.svg)

Вихідні посилання не мають значення. Тільки вхідні посилання можуть зробити об'єкт досяжним. Об'єкт John тепер недосяжний і буде видалений із пам'яті з усіма своїми даними, які також стали недоступними.

Після збирання сміття:

![](family-no-father-2.svg)

## Недосяжний "острів"

Цілком можлива ситуація, при якій цілий "острів" зв'язаних об'єктів може стати недосяжним і очиститися з пам'яті.

Візьмемо об'єкт `family` з прикладу вище. А потім:

```js
family = null;
```

Структура в пам'яті тепер стане такою:

![](family-no-family.svg)

Цей приклад демонструє, наскільки важлива концепція досяжності.

Об'єкти John і Ann все ще пов'язані, обидва мають вхідні посилання, але цього недостатньо.

У об'єкта `family` більше немає посилання від кореня, тому весь "острів" стає недосяжним і буде видалений.

## Внутрішні алгоритми

Основний алгоритм збірки сміття - "алгоритм позначок" (з англ. "Mark-and-sweep").

Згідно з цим алгоритмом, збирач сміття регулярно виконує наступні кроки:

- Збирач сміття "позначає" (запам'ятовує) всі кореневі об'єкти.
- Потім він йде по їх посиланнях і позначає всі знайдені об'єкти.
- Потім він йде по посиланнях помічених об'єктів і позначає об'єкти, на які є посилання від них. Всі об'єкти запам'ятовуються, щоб в майбутньому не відвідувати один і той же об'єкт двічі.
- ... І так далі, поки не будуть відвідані всі посилання (досяжні від коренів).
- Все непомічені об'єкти видаляються.

Наприклад, нехай наша структура об'єктів виглядає так:

![](garbage-collection-1.svg)

Явно видно "недосяжний острів" праворуч. Тепер подивимося, як буде працювати "алгоритм позначок" збирача сміття.

На першому кроці позначаються коріння:

![](garbage-collection-2.svg)

Потім позначаються об'єкти по їх посиланнях:

![](garbage-collection-3.svg)

... а потім об'єкти по їх посиланнях і так далі, поки це взагалі можливо:

![](garbage-collection-4.svg)

Тепер об'єкти, до яких не вдалося дійти від коренів, вважаються недосяжними і будуть видалені:

![](garbage-collection-5.svg)

Це і є принцип роботи збірки сміття.

Інтерпретатори JavaScript застосовують безліч оптимізацій, щоб збирання сміття працювало швидше і не впливало на продуктивність.

Ось деякі з оптимізацій:

- **Збірка за поколінням (Generational collection)** - об'єкти поділяються на "нові" і "старі". Багато об'єктів з'являються, виконують своє завдання і швидко вмирають, їх можна видаляти більш агресивно. Ті, які живуть досить довго, стають "старими" і перевіряються рідше.
- **Інкрементальна збірка (Incremental collection)** - якщо об'єктів багато, то обхід всіх посилань і позначка досяжних об'єктів може зайняти значний час і привести до видимих затримок виконання скрипта. Тому інтерпретатор намагається організувати збирання сміття поетапно. Етапи виконуються окремо один за іншим. Це вимагає додаткового обліку для відстеження змін між етапами, але зате тепер у нас є багато крихітних затримок замість однієї великої.
- **Збірка у вільний час (Idle-time collection)** - щоб зменшити можливий вплив на продуктивність, збирач сміття намагається працювати тільки під час застою процесора.

Існують й інші способи оптимізації та різновиди алгоритмів збору сміття. Але як би мені не хотілося описати їх тут, я повинен утриматися від цього, тому що різні інтерпретатори JavaScript застосовують різні прийоми і хитрощі. І, що більш важливо, все змінюється в міру розвитку інтерпретаторів, тому заглиблюватися в цю тему заздалегідь, без реальної необхідності, ймовірно, не варто. Якщо, звичайно, це не питання чистого інтересу, тоді для вас будуть корисні деякі посилання нижче.

## Підсумок

Головне з того, що ми дізналися:

- Прибирання сміття виконується автоматично. Ми не можемо прискорити або запобігти йому.
- Об'єкти зберігаються в пам'яті, поки вони досяжні.
- Наявність посилання не гарантує, що об'єкт є досяжним (від кореня): кілька взаємопов'язаних об'єктів можуть стати недосяжними як єдине ціле.

Сучасні інтерпретатори реалізують передові алгоритми збірки сміття.

Деякі з них висвітлені в книзі "The Garbage Collection Handbook: The Art of Automatic Memory Management" (R. Jones та ін.).

Якщо ви знайомі з низькорівневим програмуванням, то більш докладна інформація про збирач сміття інтерпретатора V8 знаходиться в статті [A tour of V8: Garbage Collection](http://jayconrod.com/posts/55/a-tour-of-v8-garbage -collection).

Також в [блозі інтерпретатора V8](https://v8.dev/) час від часу публікуються статті про зміни в управлінні пам'яттю. Зрозуміло, щоб вивчити збірку сміття, вам необхідно розуміти, як влаштований всередині інтерпретатор V8 в цілому. Про це ви можете почитати в блозі [В'ячеслава Єгорова](http://mrale.ph), одного з інженерів, які розробляли V8. Я говорю про "V8", тому що він краще за все освітлений статтями в інтернеті. В інших інтерпретаторів багато підходів схожі, але збірка сміття в багатьох аспектах відрізняється.

Глибоке розуміння роботи інтерпретаторів необхідно, коли вам потрібні низькорівневі оптимізації. Було б розумно запланувати їх вивчення як наступний крок після освоєння мови.
